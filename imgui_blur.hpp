// MIT License

// Copyright (c) 2023 Northn, Eray

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma once

#include <d3d9.h>
#include <limits>

#include "cimgui/imgui/imgui.h"
#include "cimgui/cimgui.h"

#ifndef DX_SAFE_RELEASE
#define DX_SAFE_RELEASE(p) if ((p) != nullptr) { (p)->Release(); (p) = nullptr; }
#endif

#ifndef DX_RETURN_FAIL
#define DX_RETURN_FAIL(v) if ((v) != D3D_OK) { return; }
#endif

namespace imgui_blur {
namespace shaders {
inline const char binary_x[] =
    "\x00\x02\xFF\xFF\xFE\xFF\x39\x00\x43\x54\x41\x42\x1C\x00\x00\x00\xAF\x00\x00\x00\x00\x02\xFF\xFF\x03\x00\x00\x00\x1C\x00\x00\x00\x00\x01\x00\x00\xA8\x00\x00\x00\x58\x00\x00\x00\x02\x00\x01\x00\x01\x00\x06\x00\x60\x00\x00\x00\x00\x00\x00\x00\x70\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x7C\x00\x00\x00\x00\x00\x00\x00\x8C\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x98\x00\x00\x00\x00\x00\x00\x00\x24\x72\x61\x64\x69\x75\x73\x00\x00\x00\x03\x00\x01\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x74\x65\x78\x53\x61\x6D\x70\x6C\x65\x72\x00\xAB\x04\x00\x0C\x00\x01\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x74\x65\x78\x65\x6C\x57\x69\x64\x74\x68\x00\xAB\x00\x00\x03\x00\x01\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x70\x73\x5F\x32\x5F\x30\x00\x4D\x69\x63\x72\x6F\x73\x6F\x66\x74\x20\x28\x52\x29\x20\x48\x4C\x53\x4C\x20\x53\x68\x61\x64\x65\x72\x20\x43\x6F\x6D\x70\x69\x6C\x65\x72\x20\x39\x2E\x32\x39\x2E\x39\x35\x32\x2E\x33\x31\x31\x31\x00\x51\x00\x00\x05\x02\x00\x0F\xA0\x14\x3B\xB1\x3F\x18\xE7\xA1\x3E\xC6\x79\x68\x3E\xEC\xC4\x4E\x40\x51\x00\x00\x05\x03\x00\x0F\xA0\xDC\xE9\x8F\x3D\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1F\x00\x00\x02\x00\x00\x00\x80\x00\x00\x03\xB0\x1F\x00\x00\x02\x00\x00\x00\x90\x00\x08\x0F\xA0\x42\x00\x00\x03\x00\x00\x0F\x80\x00\x00\xE4\xB0\x00\x08\xE4\xA0\x01\x00\x00\x02\x01\x00\x02\x80\x00\x00\x55\xB0\x01\x00\x00\x02\x02\x00\x08\x80\x00\x00\x00\xA0\x05\x00\x00\x03\x01\x00\x04\x80\x02\x00\xFF\x80\x01\x00\x00\xA0\x04\x00\x00\x04\x01\x00\x01\x80\x01\x00\xAA\x80\x02\x00\x00\xA1\x00\x00\x00\xB0\x01\x00\x00\x02\x02\x00\x02\x80\x00\x00\x55\xB0\x04\x00\x00\x04\x02\x00\x01\x80\x01\x00\xAA\x80\x02\x00\x00\xA0\x00\x00\x00\xB0\x04\x00\x00\x04\x03\x00\x01\x80\x01\x00\xAA\x80\x02\x00\xFF\xA1\x00\x00\x00\xB0\x04\x00\x00\x04\x04\x00\x01\x80\x01\x00\xAA\x80\x02\x00\xFF\xA0\x00\x00\x00\xB0\x01\x00\x00\x02\x03\x00\x02\x80\x00\x00\x55\xB0\x01\x00\x00\x02\x04\x00\x02\x80\x00\x00\x55\xB0\x42\x00\x00\x03\x01\x00\x0F\x80\x01\x00\xE4\x80\x00\x08\xE4\xA0\x42\x00\x00\x03\x02\x00\x0F\x80\x02\x00\xE4\x80\x00\x08\xE4\xA0\x42\x00\x00\x03\x03\x00\x0F\x80\x03\x00\xE4\x80\x00\x08\xE4\xA0\x42\x00\x00\x03\x04\x00\x0F\x80\x04\x00\xE4\x80\x00\x08\xE4\xA0\x05\x00\x00\x03\x01\x00\x07\x80\x01\x00\xE4\x80\x02\x00\x55\xA0\x04\x00\x00\x04\x01\x00\x07\x80\x00\x00\xE4\x80\x02\x00\xAA\xA0\x01\x00\xE4\x80\x04\x00\x00\x04\x01\x00\x07\x80\x02\x00\xE4\x80\x02\x00\x55\xA0\x01\x00\xE4\x80\x04\x00\x00\x04\x01\x00\x07\x80\x03\x00\xE4\x80\x03\x00\x00\xA0\x01\x00\xE4\x80\x04\x00\x00\x04\x00\x00\x07\x80\x04\x00\xE4\x80\x03\x00\x00\xA0\x01\x00\xE4\x80\x01\x00\x00\x02\x00\x08\x0F\x80\x00\x00\xE4\x80\xFF\xFF\x00\x00";
inline const char binary_y[] =
    "\x00\x02\xFF\xFF\xFE\xFF\x39\x00\x43\x54\x41\x42\x1C\x00\x00\x00\xAF\x00\x00\x00\x00\x02\xFF\xFF\x03\x00\x00\x00\x1C\x00\x00\x00\x00\x01\x00\x00\xA8\x00\x00\x00\x58\x00\x00\x00\x02\x00\x01\x00\x01\x00\x06\x00\x60\x00\x00\x00\x00\x00\x00\x00\x70\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x7C\x00\x00\x00\x00\x00\x00\x00\x8C\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x98\x00\x00\x00\x00\x00\x00\x00\x24\x72\x61\x64\x69\x75\x73\x00\x00\x00\x03\x00\x01\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x74\x65\x78\x53\x61\x6D\x70\x6C\x65\x72\x00\xAB\x04\x00\x0C\x00\x01\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x74\x65\x78\x65\x6C\x48\x65\x69\x67\x68\x74\x00\x00\x00\x03\x00\x01\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x70\x73\x5F\x32\x5F\x30\x00\x4D\x69\x63\x72\x6F\x73\x6F\x66\x74\x20\x28\x52\x29\x20\x48\x4C\x53\x4C\x20\x53\x68\x61\x64\x65\x72\x20\x43\x6F\x6D\x70\x69\x6C\x65\x72\x20\x39\x2E\x32\x39\x2E\x39\x35\x32\x2E\x33\x31\x31\x31\x00\x51\x00\x00\x05\x02\x00\x0F\xA0\x14\x3B\xB1\x3F\x18\xE7\xA1\x3E\xC6\x79\x68\x3E\xEC\xC4\x4E\x40\x51\x00\x00\x05\x03\x00\x0F\xA0\xDC\xE9\x8F\x3D\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1F\x00\x00\x02\x00\x00\x00\x80\x00\x00\x03\xB0\x1F\x00\x00\x02\x00\x00\x00\x90\x00\x08\x0F\xA0\x42\x00\x00\x03\x00\x00\x0F\x80\x00\x00\xE4\xB0\x00\x08\xE4\xA0\x01\x00\x00\x02\x01\x00\x01\x80\x00\x00\x00\xB0\x01\x00\x00\x02\x02\x00\x08\x80\x00\x00\x00\xA0\x05\x00\x00\x03\x01\x00\x04\x80\x02\x00\xFF\x80\x01\x00\x00\xA0\x04\x00\x00\x04\x01\x00\x02\x80\x01\x00\xAA\x80\x02\x00\x00\xA1\x00\x00\x55\xB0\x01\x00\x00\x02\x02\x00\x01\x80\x00\x00\x00\xB0\x04\x00\x00\x04\x02\x00\x02\x80\x01\x00\xAA\x80\x02\x00\x00\xA0\x00\x00\x55\xB0\x04\x00\x00\x04\x03\x00\x02\x80\x01\x00\xAA\x80\x02\x00\xFF\xA1\x00\x00\x55\xB0\x04\x00\x00\x04\x04\x00\x02\x80\x01\x00\xAA\x80\x02\x00\xFF\xA0\x00\x00\x55\xB0\x01\x00\x00\x02\x03\x00\x01\x80\x00\x00\x00\xB0\x01\x00\x00\x02\x04\x00\x01\x80\x00\x00\x00\xB0\x42\x00\x00\x03\x01\x00\x0F\x80\x01\x00\xE4\x80\x00\x08\xE4\xA0\x42\x00\x00\x03\x02\x00\x0F\x80\x02\x00\xE4\x80\x00\x08\xE4\xA0\x42\x00\x00\x03\x03\x00\x0F\x80\x03\x00\xE4\x80\x00\x08\xE4\xA0\x42\x00\x00\x03\x04\x00\x0F\x80\x04\x00\xE4\x80\x00\x08\xE4\xA0\x05\x00\x00\x03\x01\x00\x07\x80\x01\x00\xE4\x80\x02\x00\x55\xA0\x04\x00\x00\x04\x01\x00\x07\x80\x00\x00\xE4\x80\x02\x00\xAA\xA0\x01\x00\xE4\x80\x04\x00\x00\x04\x01\x00\x07\x80\x02\x00\xE4\x80\x02\x00\x55\xA0\x01\x00\xE4\x80\x04\x00\x00\x04\x01\x00\x07\x80\x03\x00\xE4\x80\x03\x00\x00\xA0\x01\x00\xE4\x80\x04\x00\x00\x04\x00\x00\x07\x80\x04\x00\xE4\x80\x03\x00\x00\xA0\x01\x00\xE4\x80\x01\x00\x00\x02\x00\x08\x0F\x80\x00\x00\xE4\x80\xFF\xFF\x00\x00";

inline IDirect3DPixelShader9 *x = nullptr;
inline IDirect3DPixelShader9 *y = nullptr;
}
inline IDirect3DTexture9 *blur_texture = nullptr;
inline IDirect3DSurface9 *rt_backup = nullptr;

namespace size {
inline float width = 0.f;
inline float height = 0.f;
}

inline bool process = false;

inline IDirect3DDevice9 *get_d3d_device() {
  return *reinterpret_cast<IDirect3DDevice9 **>(0xC97C28);
}

namespace callbacks {
inline void begin(const ImDrawList *parent_list, const ImDrawCmd *cmd) {
  auto device = get_d3d_device();

  if (shaders::x == nullptr) {
    DX_RETURN_FAIL(device->CreatePixelShader(reinterpret_cast<const DWORD *>(&shaders::binary_x), &shaders::x));
  }

  if (shaders::y == nullptr) {
    DX_RETURN_FAIL(device->CreatePixelShader(reinterpret_cast<const DWORD *>(&shaders::binary_y), &shaders::y));
  }

  const auto &display_size = igGetIO()->DisplaySize;
  const auto width = display_size.x, height = display_size.y;

  if (size::width != width || size::height != height || blur_texture == nullptr) {
    DX_SAFE_RELEASE(blur_texture);
    size::width = width;
    size::height = height;
    DX_RETURN_FAIL(device->CreateTexture(static_cast<UINT>(size::width),
                                         static_cast<UINT>(size::height),
                                         1,
                                         D3DUSAGE_RENDERTARGET,
                                         D3DFMT_A8R8G8B8,
                                         D3DPOOL_DEFAULT,
                                         &blur_texture,
                                         NULL));
  }

  DX_RETURN_FAIL(device->GetRenderTarget(0, &rt_backup));

  {
    IDirect3DSurface9 *back_buffer = nullptr;
    DX_RETURN_FAIL(device->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &back_buffer));

    IDirect3DSurface9 *surface = nullptr;
    DX_RETURN_FAIL(blur_texture->GetSurfaceLevel(0, &surface));
    DX_RETURN_FAIL(device->StretchRect(back_buffer, NULL, surface, NULL, D3DTEXF_NONE));
    DX_RETURN_FAIL(device->SetRenderTarget(0, surface));

    DX_SAFE_RELEASE(surface);
    DX_SAFE_RELEASE(back_buffer);
  }

  if (device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP) != D3D_OK ||
      device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP) != D3D_OK) {
    device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
    device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);
    return;
  }

  process = true;
}

inline void process_x(const ImDrawList *parent_list, const ImDrawCmd *cmd) {
  if (!process)
    return;

  auto device = get_d3d_device();
  auto radius = *reinterpret_cast<const float *>(&cmd->UserCallbackData);

  DX_RETURN_FAIL(device->SetPixelShader(shaders::x));

  const float params[4] = {1.0f / size::width, 1.0f / size::height};
  device->SetPixelShaderConstantF(0, params, 1);

  const float radius_params[4] = {radius};
  device->SetPixelShaderConstantF(1, radius_params, 1);
}

inline void process_y(const ImDrawList *parent_list, const ImDrawCmd *cmd) {
  if (!process)
    return;

  auto device = get_d3d_device();
  auto radius = *reinterpret_cast<const float *>(&cmd->UserCallbackData);

  DX_RETURN_FAIL(device->SetPixelShader(shaders::y));

  const float params[4] = {1.0f / size::height};
  device->SetPixelShaderConstantF(0, params, 1);

  const float radius_params[4] = {radius};
  device->SetPixelShaderConstantF(1, radius_params, 1);
}

inline void end(const ImDrawList *parent_list, const ImDrawCmd *cmd) {
  if (!process)
    return;

  auto device = get_d3d_device();

  device->SetRenderTarget(0, rt_backup);
  DX_SAFE_RELEASE(rt_backup);

  device->SetPixelShader(nullptr);
  device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
  device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);

  process = false;
}

}

void apply(ImDrawList *draw_list,
           float radius,
           const ImU32 color,
           const float rounding,
           const ImDrawCornerFlags rounding_corners,
           ImVec2 pos_min,
           ImVec2 pos_max) {
  if (draw_list == nullptr || radius <= 0 || color == 0 || pos_max.x - pos_min.x == 0.f
      || pos_max.y - pos_min.y == 0.f)
    return;

  if (pos_max.x == std::numeric_limits<float>::infinity()) {
    pos_min.x = 0.f;
    pos_min.y = 0.f;

    pos_max.x = size::width;
    pos_max.y = size::height;
  }

  if (draw_list == igGetBackgroundDrawList() || draw_list == igGetForegroundDrawList()) {
    // ImGui does not want to neither render nor add callback to drawlists without items in it
    // So... yeah, just add one!
    const auto magic_float = 999999.f;
    ImDrawList_AddLine(draw_list, {magic_float, magic_float}, {magic_float + 1.f, magic_float + 1.f}, 0x01000001, 1);
  }

  ImDrawList_AddCallback(draw_list, callbacks::begin, nullptr);

  auto add_image = [&]() {
    if (blur_texture == nullptr || size::width == 0.f || size::height == 0.f)
      return;

    ImDrawList_AddImageRounded(draw_list,
                               blur_texture,
                               pos_min,
                               pos_max,
                               {pos_min.x / size::width, pos_min.y / size::height},
                               {pos_max.x / size::width, pos_max.y / size::height},
                               color,
                               rounding,
                               rounding_corners);
  };

  while (radius > 0.0f) {
    auto radius_param = radius;

    if (radius_param > 1.f)
      radius_param = 1.f;

    ImDrawList_AddCallback(draw_list, callbacks::process_x, *reinterpret_cast<void **>(&radius_param));
    add_image();
    ImDrawList_AddCallback(draw_list, callbacks::process_y, *reinterpret_cast<void **>(&radius_param));
    add_image();
    
    radius -= 1.f;
  }

  ImDrawList_AddCallback(draw_list, callbacks::end, nullptr);
  add_image();
}

void invalidate() {
  DX_SAFE_RELEASE(blur_texture);
  DX_SAFE_RELEASE(rt_backup);
}
}
