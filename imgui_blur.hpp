// MIT License

// Copyright (c) 2023 Northn, Eray

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma once

#include <d3d9.h>
#include <limits>

#include "cimgui/imgui/imgui.h"
#include "cimgui/cimgui.h"

#ifndef DX_SAFE_RELEASE
#define DX_SAFE_RELEASE(p) if ((p) != nullptr) { (p)->Release(); (p) = nullptr; }
#endif

#ifndef DX_RETURN_FAIL
#define DX_RETURN_FAIL(v) if ((v) != D3D_OK) { return; }
#endif

namespace imgui_blur {
namespace shaders {
inline const char binary_x[] =
    "\x00\x02\xff\xff\xfe\xff\x2e\x00\x43\x54\x41\x42\x1c\x00\x00\x00\x83\x00\x00\x00\x00\x02\xff\xff\x02\x00\x00\x00\x1c\x00\x00\x00\x00\x01\x00\x00\x7c\x00\x00\x00\x44\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x50\x00\x00\x00\x00\x00\x00\x00\x60\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x6c\x00\x00\x00\x00\x00\x00\x00\x74\x65\x78\x53\x61\x6d\x70\x6c\x65\x72\x00\xab\x04\x00\x0c\x00\x01\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x74\x65\x78\x65\x6c\x57\x69\x64\x74\x68\x00\xab\x00\x00\x03\x00\x01\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x70\x73\x5f\x32\x5f\x30\x00\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x28\x52\x29\x20\x48\x4c\x53\x4c\x20\x53\x68\x61\x64\x65\x72\x20\x43\x6f\x6d\x70\x69\x6c\x65\x72\x20\x39\x2e\x32\x39\x2e\x39\x35\x32\x2e\x33\x31\x31\x31\x00\x51\x00\x00\x05\x01\x00\x0f\xa0\x14\x3b\xb1\x3f\x00\x00\x00\x00\x18\xe7\xa1\x3e\xc6\x79\x68\x3e\x51\x00\x00\x05\x02\x00\x0f\xa0\xec\xc4\x4e\x40\xdc\xe9\x8f\x3d\x00\x00\x00\x00\x00\x00\x00\x00\x1f\x00\x00\x02\x00\x00\x00\x80\x00\x00\x03\xb0\x1f\x00\x00\x02\x00\x00\x00\x90\x00\x08\x0f\xa0\x42\x00\x00\x03\x00\x00\x0f\x80\x00\x00\xe4\xb0\x00\x08\xe4\xa0\x01\x00\x00\x02\x01\x00\x08\x80\x01\x00\x00\xa0\x05\x00\x00\x03\x01\x00\x01\x80\x01\x00\xff\x80\x00\x00\x00\xa0\x01\x00\x00\x02\x01\x00\x02\x80\x01\x00\x55\xa0\x02\x00\x00\x03\x02\x00\x03\x80\x01\x00\xe4\x81\x00\x00\xe4\xb0\x02\x00\x00\x03\x01\x00\x03\x80\x01\x00\xe4\x80\x00\x00\xe4\xb0\x01\x00\x00\x02\x03\x00\x08\x80\x02\x00\x00\xa0\x05\x00\x00\x03\x03\x00\x01\x80\x03\x00\xff\x80\x00\x00\x00\xa0\x01\x00\x00\x02\x03\x00\x02\x80\x01\x00\x55\xa0\x02\x00\x00\x03\x04\x00\x03\x80\x03\x00\xe4\x81\x00\x00\xe4\xb0\x02\x00\x00\x03\x03\x00\x03\x80\x03\x00\xe4\x80\x00\x00\xe4\xb0\x42\x00\x00\x03\x01\x00\x0f\x80\x01\x00\xe4\x80\x00\x08\xe4\xa0\x42\x00\x00\x03\x02\x00\x0f\x80\x02\x00\xe4\x80\x00\x08\xe4\xa0\x42\x00\x00\x03\x03\x00\x0f\x80\x03\x00\xe4\x80\x00\x08\xe4\xa0\x42\x00\x00\x03\x04\x00\x0f\x80\x04\x00\xe4\x80\x00\x08\xe4\xa0\x05\x00\x00\x03\x02\x00\x07\x80\x02\x00\xe4\x80\x01\x00\xaa\xa0\x04\x00\x00\x04\x02\x00\x07\x80\x00\x00\xe4\x80\x01\x00\xff\xa0\x02\x00\xe4\x80\x04\x00\x00\x04\x01\x00\x07\x80\x01\x00\xe4\x80\x01\x00\xaa\xa0\x02\x00\xe4\x80\x04\x00\x00\x04\x01\x00\x07\x80\x04\x00\xe4\x80\x02\x00\x55\xa0\x01\x00\xe4\x80\x04\x00\x00\x04\x00\x00\x07\x80\x03\x00\xe4\x80\x02\x00\x55\xa0\x01\x00\xe4\x80\x01\x00\x00\x02\x00\x08\x0f\x80\x00\x00\xe4\x80\xff\xff\x00\x00";
inline const char binary_y[] =
    "\x00\x02\xff\xff\xfe\xff\x2e\x00\x43\x54\x41\x42\x1c\x00\x00\x00\x83\x00\x00\x00\x00\x02\xff\xff\x02\x00\x00\x00\x1c\x00\x00\x00\x00\x01\x00\x00\x7c\x00\x00\x00\x44\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x50\x00\x00\x00\x00\x00\x00\x00\x60\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x6c\x00\x00\x00\x00\x00\x00\x00\x74\x65\x78\x53\x61\x6d\x70\x6c\x65\x72\x00\xab\x04\x00\x0c\x00\x01\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x74\x65\x78\x65\x6c\x48\x65\x69\x67\x68\x74\x00\x00\x00\x03\x00\x01\x00\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x70\x73\x5f\x32\x5f\x30\x00\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74\x20\x28\x52\x29\x20\x48\x4c\x53\x4c\x20\x53\x68\x61\x64\x65\x72\x20\x43\x6f\x6d\x70\x69\x6c\x65\x72\x20\x39\x2e\x32\x39\x2e\x39\x35\x32\x2e\x33\x31\x31\x31\x00\x51\x00\x00\x05\x01\x00\x0f\xa0\x14\x3b\xb1\x3f\x00\x00\x00\x80\x18\xe7\xa1\x3e\xc6\x79\x68\x3e\x51\x00\x00\x05\x02\x00\x0f\xa0\xec\xc4\x4e\x40\xdc\xe9\x8f\x3d\x00\x00\x00\x00\x00\x00\x00\x00\x1f\x00\x00\x02\x00\x00\x00\x80\x00\x00\x03\xb0\x1f\x00\x00\x02\x00\x00\x00\x90\x00\x08\x0f\xa0\x42\x00\x00\x03\x00\x00\x0f\x80\x00\x00\xe4\xb0\x00\x08\xe4\xa0\x01\x00\x00\x02\x01\x00\x08\x80\x01\x00\x00\xa0\x05\x00\x00\x03\x01\x00\x01\x80\x01\x00\xff\x80\x00\x00\x00\xa0\x01\x00\x00\x02\x01\x00\x02\x80\x01\x00\x00\x81\x01\x00\x00\x02\x01\x00\x01\x80\x01\x00\x55\xa0\x02\x00\x00\x03\x01\x00\x03\x80\x01\x00\xe4\x80\x00\x00\xe4\xb0\x01\x00\x00\x02\x02\x00\x01\x80\x00\x00\x00\xb0\x04\x00\x00\x04\x02\x00\x02\x80\x00\x00\x00\xa0\x01\x00\xff\x80\x00\x00\x55\xb0\x01\x00\x00\x02\x03\x00\x08\x80\x02\x00\x00\xa0\x05\x00\x00\x03\x01\x00\x04\x80\x03\x00\xff\x80\x00\x00\x00\xa0\x01\x00\x00\x02\x03\x00\x02\x80\x01\x00\xaa\x81\x01\x00\x00\x02\x03\x00\x01\x80\x01\x00\x55\xa0\x02\x00\x00\x03\x03\x00\x03\x80\x03\x00\xe4\x80\x00\x00\xe4\xb0\x01\x00\x00\x02\x04\x00\x01\x80\x00\x00\x00\xb0\x04\x00\x00\x04\x04\x00\x02\x80\x00\x00\x00\xa0\x03\x00\xff\x80\x00\x00\x55\xb0\x42\x00\x00\x03\x01\x00\x0f\x80\x01\x00\xe4\x80\x00\x08\xe4\xa0\x42\x00\x00\x03\x02\x00\x0f\x80\x02\x00\xe4\x80\x00\x08\xe4\xa0\x42\x00\x00\x03\x03\x00\x0f\x80\x03\x00\xe4\x80\x00\x08\xe4\xa0\x42\x00\x00\x03\x04\x00\x0f\x80\x04\x00\xe4\x80\x00\x08\xe4\xa0\x05\x00\x00\x03\x01\x00\x07\x80\x01\x00\xe4\x80\x01\x00\xaa\xa0\x04\x00\x00\x04\x01\x00\x07\x80\x00\x00\xe4\x80\x01\x00\xff\xa0\x01\x00\xe4\x80\x04\x00\x00\x04\x01\x00\x07\x80\x02\x00\xe4\x80\x01\x00\xaa\xa0\x01\x00\xe4\x80\x04\x00\x00\x04\x01\x00\x07\x80\x03\x00\xe4\x80\x02\x00\x55\xa0\x01\x00\xe4\x80\x04\x00\x00\x04\x00\x00\x07\x80\x04\x00\xe4\x80\x02\x00\x55\xa0\x01\x00\xe4\x80\x01\x00\x00\x02\x00\x08\x0f\x80\x00\x00\xe4\x80\xff\xff\x00\x00";

inline IDirect3DPixelShader9 *x = nullptr;
inline IDirect3DPixelShader9 *y = nullptr;
}
inline IDirect3DTexture9 *blur_texture = nullptr;
inline IDirect3DSurface9 *rt_backup = nullptr;

namespace size {
inline float width = 0.f;
inline float height = 0.f;
}

inline bool process = false;

namespace callbacks {
inline void begin(const ImDrawList *parent_list, const ImDrawCmd *cmd) {
  auto device = reinterpret_cast<IDirect3DDevice9 *>(cmd->UserCallbackData);

  if (shaders::x == nullptr) {
    DX_RETURN_FAIL(device->CreatePixelShader(reinterpret_cast<const DWORD *>(&shaders::binary_x), &shaders::x));
  }

  if (shaders::y == nullptr) {
    DX_RETURN_FAIL(device->CreatePixelShader(reinterpret_cast<const DWORD *>(&shaders::binary_y), &shaders::y));
  }

  const auto &display_size = igGetIO()->DisplaySize;
  const auto width = display_size.x, height = display_size.y;

  if (size::width != width || size::height != height || blur_texture == nullptr) {
    DX_SAFE_RELEASE(blur_texture);
    size::width = width;
    size::height = height;
    DX_RETURN_FAIL(device->CreateTexture(static_cast<UINT>(size::width) + 1,
                                         static_cast<UINT>(size::height) + 1,
                                         1,
                                         D3DUSAGE_RENDERTARGET,
                                         D3DFMT_A8R8G8B8,
                                         D3DPOOL_DEFAULT,
                                         &blur_texture,
                                         NULL));
  }

  DX_RETURN_FAIL(device->GetRenderTarget(0, &rt_backup));

  {
    IDirect3DSurface9 *back_buffer = nullptr;
    DX_RETURN_FAIL(device->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &back_buffer));

    IDirect3DSurface9 *surface = nullptr;
    DX_RETURN_FAIL(blur_texture->GetSurfaceLevel(0, &surface));
    DX_RETURN_FAIL(device->StretchRect(back_buffer, NULL, surface, NULL, D3DTEXF_NONE));
    DX_RETURN_FAIL(device->SetRenderTarget(0, surface));

    DX_SAFE_RELEASE(surface);
    DX_SAFE_RELEASE(back_buffer);
  }

  if (device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP) != D3D_OK ||
      device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP) != D3D_OK) {
    device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
    device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);
    return;
  }

  process = true;
}

inline void process_x(const ImDrawList *parent_list, const ImDrawCmd *cmd) {
  if (!process)
    return;
  auto device = reinterpret_cast<IDirect3DDevice9 *>(cmd->UserCallbackData);

  DX_RETURN_FAIL(device->SetPixelShader(shaders::x));
  const float params[4] = {1.0f / size::width};
  device->SetPixelShaderConstantF(0, params, 1);
}

inline void process_y(const ImDrawList *parent_list, const ImDrawCmd *cmd) {
  if (!process)
    return;
  auto device = reinterpret_cast<IDirect3DDevice9 *>(cmd->UserCallbackData);

  DX_RETURN_FAIL(device->SetPixelShader(shaders::y));
  const float params[4] = {1.0f / size::height};
  device->SetPixelShaderConstantF(0, params, 1);
}

inline void end(const ImDrawList *parent_list, const ImDrawCmd *cmd) {
  if (!process)
    return;
  auto device = reinterpret_cast<IDirect3DDevice9 *>(cmd->UserCallbackData);

  device->SetRenderTarget(0, rt_backup);
  DX_SAFE_RELEASE(rt_backup);

  device->SetPixelShader(nullptr);
  device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
  device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);

  process = false;
}

}

void apply(ImDrawList *draw_list,
           const int radius,
           const ImU32 color,
           const float rounding,
           const ImDrawCornerFlags rounding_corners,
           ImVec2 pos_min,
           ImVec2 pos_max) {
  if (draw_list == nullptr || radius <= 0 || color == 0 || pos_max.x - pos_min.x == 0.f
      || pos_max.y - pos_min.y == 0.f)
    return;

  if (pos_max.x == std::numeric_limits<float>::infinity()) {
    pos_min.x = 0.f;
    pos_min.y = 0.f;

    pos_max.x = size::width;
    pos_max.y = size::height;
  }

  auto device = *reinterpret_cast<IDirect3DDevice9 **>(0xC97C28);

  if (draw_list == igGetBackgroundDrawList() || draw_list == igGetForegroundDrawList()) {
    // ImGui does not want to neither render nor add callback to drawlists without items in it
    // So... yeah, just add one!
    const auto magic_float = 999999.f;
    ImDrawList_AddLine(draw_list, {magic_float, magic_float}, {magic_float + 1.f, magic_float + 1.f}, 0x01000001, 1);
  }

  ImDrawList_AddCallback(draw_list, callbacks::begin, device);

  auto add_image = [&]() {
    if (blur_texture == nullptr || size::width == 0.f || size::height == 0.f)
      return;

    ImDrawList_AddImageRounded(draw_list,
                               blur_texture,
                               pos_min,
                               pos_max,
                               {pos_min.x / size::width, pos_min.y / size::height},
                               {pos_max.x / size::width, pos_max.y / size::height},
                               color,
                               rounding,
                               rounding_corners);
  };

  for (auto i = 0; i < radius; ++i) {
    ImDrawList_AddCallback(draw_list, callbacks::process_x, device);
    add_image();
    ImDrawList_AddCallback(draw_list, callbacks::process_y, device);
    add_image();
  }

  ImDrawList_AddCallback(draw_list, callbacks::end, device);
  add_image();
}

void invalidate() {
  DX_SAFE_RELEASE(blur_texture);
  DX_SAFE_RELEASE(rt_backup);
}
}
